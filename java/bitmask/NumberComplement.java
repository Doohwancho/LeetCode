package mayChallenge;

public class NumberComplement {
	
	//<문제풀이1>
	
	//비트연산자 쓰는 재미난 문제.
	
	//num이 5일때, num의 complement는 2란다.
	
	//이게 뭔말이냐면, 숫자 5를 2진수(bitmask)로 바꾸면
	
	//0000 0000 0000 0000 0000 0000 0000 0101
	
	//이렇게 된다.
	
	//여기서 이 이진수의 complement는 앞에 나오는 무수한 0들을 빼고, 나머지 101만 가지고 봤을 때,
	
	//1을 0으로, 0을 1로 바꾼 것이다. 즉, 아래와 같이 된다.
	
	//0000 0000 0000 0000 0000 0000 0000 0010
	
	//그리고 이 이진수는 다시 숫자로 변환하면 2라는 숫자가 나온다.
	
	//문제는 어떻게 주어진 num을 complement한 숫자로 바꾸냐는것인데..
	
	//일단 왼쪽에 나오는 무수한 0들은 어짜피 안쓰니까, 가장 첫번째로 등장하는 1의 위치를 찾고,
	
	//거기서부터 끝까지 for문을 돌면서, 1이면 0으로 바꿔주고, 0이면 1로 바꿔주면 되겠지?
	
	//그럼  가장 첫번쨰로 등장하는 1의 위치는 어떻게 찾을까?
	
	//자바 Integer class에서 지원하는 .numberOfLeadingZeros()를 이용하면, 맨 첫번째 1이 오른쪽 기준으로 몇번쨰에 등장하는지 알 수 있다.
	
	//그리고 1->0, 0->1로 바꾸는 것은, num = num ^ (1<<i); 을 이용하면 된다.
	
	//여기서 ^연산자는 xor 논리연산자로, 두 bitmask를 비교했을 때, 같으면 0으로, 다르면 1로 만들어주는 것이고,
	
	//(1<<i)에서 <<는, 
	
	//0000 0000 0000 0000 0000 0000 0000 0000
	
	//여기에서 맨 오른쪽 기준으로 i만큼 이동 후, 1로 바꿔주라는 말이다.
	
	//예를들어, (1<<3)은
	
	//0000 0000 0000 0000 0000 0000 0000 0100
	
	//이 되어, 8이된다.
	
	//그래서 num = num ^ (1<<i); 이게 대체 뭔말이냐.
	
	//5의 비트마스크가 이렇게 생겼다 그랬지?
	
	//0000 0000 0000 0000 0000 0000 0000 0101
	
	//그리고 31 - Integer.numberOfLeadingZeros(num);은 3이겠지?
	
	//(1<<i)은 오른쪽으로 부터 3번째 칸의 0을 1로 바꿔주라는거야.
	
	//그럼 이렇게 되겠지?
	
	//0000 0000 0000 0000 0000 0000 0000 0100
	
	//그 다음, 이거랑 num이랑 xor연산자(^)를 하는거야.
	
	//0000 0000 0000 0000 0000 0000 0000 0101  (xor)
	//0000 0000 0000 0000 0000 0000 0000 0100
	
	//xor연산이 뭐라그랬더라? 같으면 0, 다르면 1로 바꿔준다 그랬지?
	
	//그럼 왼쪽에 쌓여있는 0들은 둘다 똑같이 0이니까, 바뀌는거 없고 
	
	//오른쪽에서 부터 3번째 칸의 1은 같으니까 0으로 되겠지?
	
	//그럼 이렇게 돼.
	
	//0000 0000 0000 0000 0000 0000 0000 0001
	
	//두번째 loop에서 num = num ^ (1<<i);을 할 떄, i가 2니까,
	
	//0000 0000 0000 0000 0000 0000 0000 0010 가 되겠지?
	
	//그럼,
	
	//0000 0000 0000 0000 0000 0000 0000 0010 (xor)
	//0000 0000 0000 0000 0000 0000 0000 0001
	
	//하면, 
	
	//0000 0000 0000 0000 0000 0000 0000 0011
	
	//이렇게 되구.
	
	//마지막에 1<<1랑 xor하면,
	
	//0000 0000 0000 0000 0000 0000 0000 0011 (xor)
	//0000 0000 0000 0000 0000 0000 0000 0001
	
	//결과값이 
	
	//0000 0000 0000 0000 0000 0000 0000 0010
	
	//이렇게 되겠지?
	
	//이걸 숫자로 바꾼게 2야. 그래서 답이 2가 되는거야.
	
	// 149 / 149 test cases passed.
    // Status: Accepted
    // Runtime: 0 ms
    // Memory Usage: 36.5 MB
    public int findComplement(int num) {
        for(int i = 31 - Integer.numberOfLeadingZeros(num); i >= 0; i--) {
			num = num ^ (1<<i);
		}
        return num;
    }
}
