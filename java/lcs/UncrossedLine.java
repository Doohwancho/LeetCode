package mayChallenge;

public class UncrossedLine {
	
	/*
	//<Trial01>
	
	//greedy로 
	
	//A->B 앞,뒤
	
	//B->A 앞,뒤 
	
	//해서 최대값 뽑는거로 짰긴했는데 실패.
	
	//넘 단순하게 했나;
	
    public static int maxUncrossedLines(int[] A, int[] B) {
    	int first = 0;
    	int second = 0;
    	int i = 0, i_ = 0, j = 0, j_ = 0;
    	
    	while((i < A.length && j < B.length) && (j_ < A.length || i_ < B.length)) {
        	if(i_ < B.length) {
        		int orgI = i_;
        		
        		while(i_ < B.length && A[i] != B[i_]) {
                	i_++;
                }
        		
        		if(i_ == B.length) {
        			i_ = orgI;
        			i++;
        		}
        		else if(A[i]==B[i_]) {
                	first++;
                	i++;
                	i_++;
                }
        	}
            if(j_ < A.length) {
            	int orgJ = j_;
            	
            	while(j_ < A.length && B[j] != A[j_]) {
                	j_++;
                }
            	
            	if(j_ == A.length) {
            		j_ = orgJ;
            		j++;
            	}
            	else if(B[j]==A[j_]) {
                	second++;
                	j++;
                	j_++;
                }
            }
    	}
        
        
        int third = 0;
    	int fourth = 0;
    	int p = A.length-1, p_ = B.length-1, q = B.length-1, q_ = A.length-1;
    	
    	while((p >= 0 && q >= 0) && (p_ >= 0 || q_ >= 0)) {
        	if(p_ >= 0) {
        		int orgP = p_;
        		
        		while(p_ >= 0 && A[p] != B[p_]) {
                	p_--;
                }
        		
        		if(p_ == -1) {
        			p_ = orgP;
        			p--;
        		}
        		else if(A[p]==B[p_]) {
                	third++;
                	p--;
                	p_--;
                }
        	}
            if(q_ >= 0) {
            	int orgQ = q_;
            	
            	while(q_ >= 0 && B[q] != A[q_]) {
                	q_--;
                }
            	
            	if(q_ == -1) {
            		q_ = orgQ;
            		q--;
            	}
            	else if(B[q]==A[q_]) {
                	fourth++;
                	q--;
                	q_--;
                }
            }
    	}
        return Math.max(Math.max(first, second), Math.max(third, fourth));
    }
    */
	
    //<문제풀이1 by lee215>
    
    //dynamic programming(similar to LCS<longest common sequence> algorithm)
	
	//int[] A = {1,2,3,4,5};
	//int[] B = {1,5,2,3,4};
	
	//이렇게 넣으면,
	
	//0 0 0 0 0 0 
	//0 1 0 0 0 0 
	//0 0 0 0 0 0 
	//0 0 0 0 0 0 
	//0 0 0 0 0 0 
	//0 0 0 0 0 0 
	
	//0 0 0 0 0 0 
	//0 1 1 0 0 0 
	//0 0 0 0 0 0 
	//0 0 0 0 0 0 
	//0 0 0 0 0 0 
	//0 0 0 0 0 0 
	
	//0 0 0 0 0 0 
	//0 1 1 1 0 0 
	//0 0 0 0 0 0 
	//0 0 0 0 0 0 
	//0 0 0 0 0 0 
	//0 0 0 0 0 0 
	
	//0 0 0 0 0 0 
	//0 1 1 1 1 0 
	//0 0 0 0 0 0 
	//0 0 0 0 0 0 
	//0 0 0 0 0 0 
	//0 0 0 0 0 0 
	
	//0 0 0 0 0 0 
	//0 1 1 1 1 1 
	//0 0 0 0 0 0 
	//0 0 0 0 0 0 
	//0 0 0 0 0 0 
	//0 0 0 0 0 0 
	
	//0 0 0 0 0 0 
	//0 1 1 1 1 1 
	//0 1 0 0 0 0 
	//0 0 0 0 0 0 
	//0 0 0 0 0 0 
	//0 0 0 0 0 0 
	
	//0 0 0 0 0 0 
	//0 1 1 1 1 1 
	//0 1 1 0 0 0 
	//0 0 0 0 0 0 
	//0 0 0 0 0 0 
	//0 0 0 0 0 0 
	
	//0 0 0 0 0 0 
	//0 1 1 1 1 1 
	//0 1 1 2 0 0 
	//0 0 0 0 0 0 
	//0 0 0 0 0 0 
	//0 0 0 0 0 0 
	
	//0 0 0 0 0 0 
	//0 1 1 1 1 1 
	//0 1 1 2 2 0 
	//0 0 0 0 0 0 
	//0 0 0 0 0 0 
	//0 0 0 0 0 0 
	
	//0 0 0 0 0 0 
	//0 1 1 1 1 1 
	//0 1 1 2 2 2 
	//0 0 0 0 0 0 
	//0 0 0 0 0 0 
	//0 0 0 0 0 0 
	
	//0 0 0 0 0 0 
	//0 1 1 1 1 1 
	//0 1 1 2 2 2 
	//0 1 0 0 0 0 
	//0 0 0 0 0 0 
	//0 0 0 0 0 0 
	
	//0 0 0 0 0 0 
	//0 1 1 1 1 1 
	//0 1 1 2 2 2 
	//0 1 1 0 0 0 
	//0 0 0 0 0 0 
	//0 0 0 0 0 0 
	
	//0 0 0 0 0 0 
	//0 1 1 1 1 1 
	//0 1 1 2 2 2 
	//0 1 1 2 0 0 
	//0 0 0 0 0 0 
	//0 0 0 0 0 0 
	
	//0 0 0 0 0 0 
	//0 1 1 1 1 1 
	//0 1 1 2 2 2 
	//0 1 1 2 3 0 
	//0 0 0 0 0 0 
	//0 0 0 0 0 0 
	
	//0 0 0 0 0 0 
	//0 1 1 1 1 1 
	//0 1 1 2 2 2 
	//0 1 1 2 3 3 
	//0 0 0 0 0 0 
	//0 0 0 0 0 0 
	
	//0 0 0 0 0 0 
	//0 1 1 1 1 1 
	//0 1 1 2 2 2 
	//0 1 1 2 3 3 
	//0 1 0 0 0 0 
	//0 0 0 0 0 0 
	
	//0 0 0 0 0 0 
	//0 1 1 1 1 1 
	//0 1 1 2 2 2 
	//0 1 1 2 3 3 
	//0 1 1 0 0 0 
	//0 0 0 0 0 0 
	
	//0 0 0 0 0 0 
	//0 1 1 1 1 1 
	//0 1 1 2 2 2 
	//0 1 1 2 3 3 
	//0 1 1 2 0 0 
	//0 0 0 0 0 0 
	
	//0 0 0 0 0 0 
	//0 1 1 1 1 1 
	//0 1 1 2 2 2 
	//0 1 1 2 3 3 
	//0 1 1 2 3 0 
	//0 0 0 0 0 0 
	
	//0 0 0 0 0 0 
	//0 1 1 1 1 1 
	//0 1 1 2 2 2 
	//0 1 1 2 3 3 
	//0 1 1 2 3 4 
	//0 0 0 0 0 0 
	
	//0 0 0 0 0 0 
	//0 1 1 1 1 1 
	//0 1 1 2 2 2 
	//0 1 1 2 3 3 
	//0 1 1 2 3 4 
	//0 1 0 0 0 0 
	
	//0 0 0 0 0 0 
	//0 1 1 1 1 1 
	//0 1 1 2 2 2 
	//0 1 1 2 3 3 
	//0 1 1 2 3 4 
	//0 1 2 0 0 0 
	
	//0 0 0 0 0 0 
	//0 1 1 1 1 1 
	//0 1 1 2 2 2 
	//0 1 1 2 3 3 
	//0 1 1 2 3 4 
	//0 1 2 2 0 0 
	
	//0 0 0 0 0 0 
	//0 1 1 1 1 1 
	//0 1 1 2 2 2 
	//0 1 1 2 3 3 
	//0 1 1 2 3 4 
	//0 1 2 2 3 0 
	
	//0 0 0 0 0 0 
	//0 1 1 1 1 1 
	//0 1 1 2 2 2 
	//0 1 1 2 3 3 
	//0 1 1 2 3 4 
	//0 1 2 2 3 4 
	
	//4
	
    public static int maxUncrossedLines(int[] A, int[] B) {
        int m = A.length, n = B.length, dp[][] = new int[m + 1][n + 1];
        for (int i = 1; i <= m; ++i) {
            for (int j = 1; j <= n; ++j) {
                if (A[i - 1] == B[j - 1]) {
                    dp[i][j] = 1 + dp[i - 1][j - 1];
                }
                else {
                    dp[i][j] = Math.max(dp[i][j - 1], dp[i - 1][j]);
                }
            }
        }
        return dp[m][n];
    }
    
}
