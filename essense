
---
1. Why problem-solve?



a. logical reasoning skills: deducting a -> b -> c -> d, planning & simulating ahead
b. 이걸 배움으로 보지 못했던것을 볼 수 있고, 생각하지 못했던 것을 생각할 수 있게 되는 것.
c. 공부는 버티는게 아니라 원래 재밌는 것임을 느끼기 위해.
	역설적이게도, 공부는 적당히 하면 재미없고, 많이하면 오히려 재미있다. 일단 공부습관이 생기게 되면, 뇌의 관성 때문에 공부하고 또 공부한다. 놀고 싶다는 마음 자체가 생기지 않는다. 머리가 몸에게 공부하라고 명령하는게 아니라, 일단 몸이 저절로 공부하는 자세를 취한다. 공부를 하다가 '여가시간을 가져야 하지 않을까?'라는 생각이 든다는 것은, 공부습관이 없는 상태에서나 해당되는 말이다.

d. learn self-discipline. 하기 싫은걸 억지로 하는게 아닌, 스스로와 약속을 하고 그 약속을 지킴으로 인해 성숙해 지기 위해.


e. learn data-structure
f. learn different algorithms
g. familiarize with programming language

importance in order

a > b > c > d >>>>>>>>>>>> e > f > g






---
2. What is learning?


격-물
fitting new idea into previously made mold(knowledge-tree)

if mold doesn't exist or is a shitty one, break the old one and re-build it with new idea.



**배움에 대한 오해

공부는 버티는게 아니다.  배움은 원래 재밌는 것이다.

PS도 재밌어서 하는 것이다. 






---
3. ratios


70:20:10 = familiarize:practice:study


**many skip familiarize part, and eventually get bored out.

familiarize part is the most important part in fact.





---
4. How to learn PS effectively?







-beginer level


goal: know why you want to PS. familiarize. gain positive feelings & attitude towards PS.





0. know why you want to learn PS.
	
	What do you desire?
	
	what do you get from PS?




1. do super easy questions first, many times. 

	complete many easy questions to, 

	A. get a mere grasp of what PS is
	B. get a positive feelings/attitude towards PS by stacking up accomplishments(= # of solved questions)

	quantity >>> quality

	it's okay to brute-force as long as it passes it.





2. if you have no idea how to solve it, it's okay to look it up fast.

	b/c easy questions don't test you on logical reasoning. 

	easy questions simply test you whether you know certain data structure or not.






3. Do one PS a day & leave every trace of your work on github.





-intermediate level



goal: practice:study







0. everytime before PS, read your own essense file that tells you why you PS & how you PS.





1. build your own knowledge-tree

	everytime you solve a question, 
	
	a. think of which PS개념 you archived in your knowledge tree you want to use, 
	b. how you will connect them A-B-C step by step

	when you learn a new idea, emphasize with creator of this idea: why he made this in the first place?
	





2. never start coding before you finish with your logic in your head/note/blackboard from A-Z.
	
	** 문제를 반복해서 푸는 것, 쉬운 문제를 풀어 재끼는 것은 실력향상과 아무연관이 없음.

	quality >>>>> quantity

	knowledge-tree에 있던 개념을 어떻게 step-by-step으로 적용할 것인지 생각할때'만' 실력향상.

	never set time on PS. it makes you anxious & you feel pressure to 풀어제낌 PS w/out logical reasoning





3. if you can't figure it out, instead of looking whole part of solution, look at part of solution and try to build up from there on you own.




4. even if you've figured it out, try different approaches. 

	우리가 미디어에 빠지는 것 처럼, 별로 즐거울것 같지 않은 일에 집중하게 만들 수 있다.
	어느일이던 자발성과 참신성이 더해지면 재미있다.
	재미란 남들이 못보는 가변성을 찾는 것이다. 따분함과 단조로움을 돌파해,
	숨어있는 아름다움을 찾는 것이다.
	ex) 잔디깎이가 개노잼처럼 보이겠지만, 타임어택을 한다던지,
	결이 고르게 중점적으로 깎는다던지,
	삼각형 -> 사각형 -> 별 -> 원 -> 특정 모양 그리기 -> ...
	가변성을 더하면 재밌어 진다.

	이렇게 계속 연습해 나가다 보면, 잘하게 되는데, 잘하는건 재밌다.
	테트리스는 재미없지만, 만약 세계 최고의 테트리스 플레이어면,
	재밌어서 매일 연습하고 싶어질껄?



5. explain in simple words

	by explaining the idea in simple words,
	you deconstruct & reconstruct previously made mold.
	very natural process of the universe.


6. Do at least one PS a day & leave every trace of your work on github




7. you put 100, and only get 30. 70 frictioned away.  

	a. 등가교환의 법칙. 100을 넣고 100 이상을 바라지 말것.
	b. 70 friction은 방법론학습 + 경험으로 점차 줄어듬.


